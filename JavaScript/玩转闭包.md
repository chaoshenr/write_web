### 写在前面
在初入前端，了解到JS的“闭包”这一特殊存在时，我感到异常兴奋。因为之前是开发iOS应用的缘故，我对Objective-C中的Block(闭包)已使用的较为熟练，并且对Block的灵活，跨作用域访问变量的能力而感到吃惊。因此对JS的“闭包”的能力有着同样的期待，经过深入的学习后，越来越觉得JS的闭包比之OC的Block更加灵活多变，且易于理解。下面我就来谈谈我对闭包的理解。

### 什么是闭包？
是语法吗？当然不是，在JavaScript中，闭包只是基于词法作用域书写代码时所产生的的自然结果。我们初学闭包时，通过网上查找资料，会存在对闭包的解释如：    
(1)闭包是函数内的函数   
(2)能访问其他作用域的变量的函数都是闭包  

整体来说，算是对的，但是又过于简单和无法立刻明白其内在原理和机制。
那怎样理解闭包呢？   
我的理解：在JS中，由于函数是一等公民，能够记住（即引用）并访问其所在的词法作用域(上下文)，并且该函数是在当前作用域之外执行，就形成了我们所说的“闭包”。   

下面我们通过示例分析下。  

### 闭包实例 1
```
C();

function A() {
	var a_innerVar = "A";
	function B(arg) {
		console.log("我能访问 " + a_innerVar + " 作用域中的变量");
		console.log("我也能使用 " + arg + " 作用域中的变量");
	}
	return B
}

function C() {
	var c_innerVar = "C";
	var bFunc = A();
	bFunc(c_innerVar);

}
```
上面的代码示例是我们初入前端是常看到的，即在一个函数内将另外一个函数作为结果返回。  

为了能够更加容易理解闭包，在脑海中我们先暂时把闭包的概念放在一边。我们能够接受的是，JS解释器对代码的编译是从上往下，一行接着一行执行代码的(抑或是对执行到的上下文进行层层编译，因为上下文有着运行时确定的特性)。   

正文从这里开始：
	首先，我们看到代码片段中的三个函数最先调用的是C，那么我们就从C开始，C的内部声明了一个局部变量"c_innerVar"，然后调用了函数A，通过解释器对代码的编译机制，此时函数C可替换成如下：

```
function C() {
	var c_innerVar = "C";	
	var bFunc = A();
	function A() {
		var a_innerVar = "A";
		function B(arg) {
	 		console.log("我能访问 " + a_innerVar + " 作用域中的变量");
	 		console.log("我也能使用 " + arg + " 作用域中的变量");
	 	}
		return B
	}
	bFunc(c_innerVar);

}
```
B在A的作用域内，能够访问其作用域内的变量是很显然的，但是，对于作为结果返回的函数B也会对A作用域的变量进行引用，使函数A即使执行完了，其作用域内的变量也不会完全释放。所以当bFunc(即函数B)执行时能够继续使用A作用域内的变量。对于bFunc调用时能够使用C作用域的变量，这个毫无疑问，因为bFunc的执行作用域是C。 

掌握闭包需要理解一下两点：       
`1.闭包函数(示例中的B)会对定义时(函数的创建)所在的作用域的变量进行引用，使其无法被释放。   `
`2.闭包函数执行时所在的作用域(C)，跟其定义时所在的作用域(A)不同`   

### 闭包实例 2
```
function A(fn) {
	var a_innerVar = "A";
	console.log("你好我是 A");
	fn(a_innerVar);
}
C();
function C() {
	var c_innerVar = "C"
	A(function B(arg) {
		console.log("你好, " + arg + "，我是 B");
		console.log("此时我在 "+ c_innerVar + " 的内部")
	})
}

```
有没有很熟悉！没错，当我们使用AJAX进行网络请求时，经常会使用到这种把函数当成参数传入的方式而形成闭包的场景。       
结合上面我们对闭包的两点总结，来分析下上面的示例。       
从上面的示例可以看出，B定义时的作用域是C，可访问C内部的变量并对C作用域内部的变量进行引用。当A执行时，由于B作为参数被传入了A，并且B执行时的作用域是A，那么是能够访问A作用域内部的变量的。     

通过以上两个示例的分析，我们应该能够看出，闭包的确不是什么语法，只是编译器编译代码时，某个函数的词法作用域的切换，形成的一种函数使用方式而已。   

### 为什么要使用闭包呢？
由于作用域链的关系，内部作用域可以访问外部作用域的变量，但外部作用域不能访问内部的。所以当我们既想让外部作用域访问内部作用域的变量，又不想让内部作用域的变量暴露出来，避免被外界任意修改。因此就产生了闭包，以隐蔽的方式来支持外部作用域访问内部作用域的变量。  

当然大量的使用闭包，也是不合理的，因为闭包会对其定义时的作用域的变量进行引用而无法释放，所以会产生内存泄漏的风险。尽量只有在需要用到的时候才去使用，无需刻意使用。 


